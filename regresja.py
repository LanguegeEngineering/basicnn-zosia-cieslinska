# -*- coding: utf-8 -*-
"""regresja.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GQCXpscdpH4IfrIezlBz2pPIHXxKLIMA
"""

import numpy as np
import torch
import matplotlib.pyplot as plt

# D_in is input dimension;
# D_out is output dimension.

D_in, D_out = 1, 1

x_numpy = np.arange(11).reshape(11,1)

y_numpy = x_numpy * 9.81

plt.plot(x_numpy, y_numpy)
plt.ylabel('Wartość siły')
plt.xlabel('Masa')
plt.show()

"""Sieć neuronowa:"""

x = torch.from_numpy(x_numpy).float()
y = torch.from_numpy(y_numpy).float()


model = torch.nn.Sequential(
    torch.nn.Linear(D_in, D_out)
)
loss_fn = torch.nn.MSELoss(reduction='sum')

epochs = 10
learning_rate = 1e-4
optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)


for t in range(epochs):
    # Forward pass
    y_pred = model(x)

    # Compute and print loss.
    loss = loss_fn(y_pred, y)
    #print(t, loss.item())
    optimizer.zero_grad()

    # Backward pass
    loss.backward()

    # Update to parameters
    optimizer.step()
    
y_test = model(x).data.numpy()

plt.plot(x_numpy, y_numpy,  label = 'from data', alpha = .5)
plt.plot(x_numpy, y_test, 'go', label = 'prediction', alpha = 0.5)
plt.legend()
plt.show()

"""### Zadanie 

Zrobić to samo dla dowolnej zdefiniowanej przez siebie funkcji wielomianowej stopnia co najmniej drugiego. Zaobserwować jak predykcja zachowuje się poza granicami zbioru treningowego.
"""

